## 接口日志,重放接口 AOP实现

### 整体目录

![image-20241223195527230](https://note-1259190304.cos.ap-chengdu.myqcloud.com/noteimage-20241223195527230.png)

### 接口日志实体

```java
package com.yupi.springbootinit.example.interfaceaop.model;

import com.baomidou.mybatisplus.annotation.*;
import lombok.Data;

import java.io.Serializable;
import java.util.Date;

/**
 * API 调用日志
 */
@Data
@TableName(value = "api_log")
public class ApiLog implements Serializable {

    /**
     * 主键
     */
    @TableId(type = IdType.AUTO)
    private Long id;

    /**
     * 请求唯一标识
     */
    @TableField(value = "request_id")
    private String requestId;

    /**
     * 请求URL
     */
    @TableField(value = "url")
    private String url;

    /**
     * HTTP方法
     */
    @TableField(value = "http_method")
    private String httpMethod;

    /**
     * 请求IP
     */
    @TableField(value = "ip")
    private String ip;

    /**
     * 调用方法
     */
    @TableField(value = "class_method")
    private String classMethod;

    /**
     * 请求参数
     */
    @TableField(value = "request_params")
    private String requestParams;

    /**
     * 响应数据
     */
    @TableField(value = "response_data")
    private String responseData;

    /**
     * 请求耗时(ms)
     */
    @TableField(value = "time_consumed")
    private Long timeConsumed;

    /**
     * 用户ID
     */
    @TableField(value = "user_id")
    private String userId;

    /**
     * 创建时间
     */
    @TableField(value = "create_time")
    private Date createTime;

    /**
     * 更新时间
     */
    @TableField(value = "update_time")
    private Date updateTime;

    /**
     * 是否删除
     */
    @TableField(value = "is_deleted")
    @TableLogic
    private Integer isDeleted;

    @TableField(exist = false)
    private static final long serialVersionUID = 1L;
}
```

### sql语句

```sql
-- 接口日志表
CREATE TABLE api_log (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    request_id VARCHAR(64) NOT NULL COMMENT '请求唯一标识',
    url VARCHAR(255) NOT NULL COMMENT '请求URL',
    http_method VARCHAR(10) NOT NULL COMMENT 'HTTP方法',
    ip VARCHAR(64) NOT NULL COMMENT '请求IP',
    class_method VARCHAR(255) NOT NULL COMMENT '调用方法',
    request_params TEXT COMMENT '请求参数',
    response_data TEXT COMMENT '响应数据',
    time_consumed BIGINT COMMENT '耗时(ms)',
    user_id VARCHAR(64) COMMENT '用户ID',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    is_deleted TINYINT NOT NULL DEFAULT 0 COMMENT '是否删除'
);

-- 请求记录表
CREATE TABLE IF NOT EXISTS `api_request_record` (
    `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
    `url` varchar(255) NOT NULL COMMENT '请求URL',
    `http_method` varchar(10) NOT NULL COMMENT 'HTTP方法',
    `headers` text COMMENT '请求头',
    `request_params` text COMMENT '请求参数',
    `response_data` text COMMENT '响应数据',
    `status` int DEFAULT NULL COMMENT '请求状态',
    `time_consumed` bigint DEFAULT NULL COMMENT '耗时(ms)',
    `user_id` varchar(64) DEFAULT NULL COMMENT '用户ID',
    `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    `is_deleted` tinyint NOT NULL DEFAULT '0' COMMENT '是否删除',
    PRIMARY KEY (`id`),
    KEY `idx_create_time` (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='接口请求记录表';

ALTER TABLE `api_request_record`
    ADD COLUMN `content_type` varchar(128) DEFAULT NULL COMMENT '请求内容类型' AFTER `headers`,
    ADD COLUMN `is_array_request` tinyint(1) DEFAULT '0' COMMENT '是否数组请求' AFTER `time_consumed`;
```



### 重放日志实体

```java
package com.yupi.springbootinit.example.interfaceaop.model;

import com.baomidou.mybatisplus.annotation.*;
import lombok.Data;

import java.io.Serializable;
import java.util.Date;

/**
 * 接口请求记录
 */
@Data
@TableName(value = "api_request_record")
public class ApiRequestRecord implements Serializable {

    /**
     * 主键
     */
    @TableId(type = IdType.AUTO)
    private Long id;

    /**
     * 请求URL
     */
    @TableField(value = "url")
    private String url;

    /**
     * HTTP方法
     */
    @TableField(value = "http_method")
    private String httpMethod;

    /**
     * 请求头
     */
    @TableField(value = "headers")
    private String headers;

    /**
     * 请求参数
     */
    @TableField(value = "request_params")
    private String requestParams;

    /**
     * 请求内容类型
     */
    @TableField(value = "content_type")
    private String contentType;

    /**
     * 是否是数组请求
     */
    @TableField(value = "is_array_request")
    private Boolean isArrayRequest;

    /**
     * 响应数据
     */
    @TableField(value = "response_data")
    private String responseData;

    /**
     * 请求状态
     */
    @TableField(value = "status")
    private Integer status;

    /**
     * 耗时(ms)
     */
    @TableField(value = "time_consumed")
    private Long timeConsumed;

    /**
     * 用户ID
     */
    @TableField(value = "user_id")
    private String userId;

    /**
     * 创建时间
     */
    @TableField(value = "create_time")
    private Date createTime;

    /**
     * 更新时间
     */
    @TableField(value = "update_time")
    private Date updateTime;

    /**
     * 是否删除
     */
    @TableField(value = "is_deleted")
    @TableLogic
    private Integer isDeleted;

    @TableField(exist = false)
    private static final long serialVersionUID = 1L;
}
```



### mapper层

```java
package com.yupi.springbootinit.example.interfaceaop.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.yupi.springbootinit.example.interfaceaop.model.ApiLog;
import org.apache.ibatis.annotations.Mapper;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/23
 */
@Mapper
public interface ApiLogMapper extends BaseMapper<ApiLog> {
}
```

```java
package com.yupi.springbootinit.example.interfaceaop.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.yupi.springbootinit.example.interfaceaop.model.ApiRequestRecord;
import org.apache.ibatis.annotations.Mapper;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/23
 */
@Mapper
public interface ApiRequestRecordMapper extends BaseMapper<ApiRequestRecord> {
}
```



### service层

```java
package com.yupi.springbootinit.example.interfaceaop.service;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/23
 */
public interface ApiReplayService {

    /**
     * 重放日志
     * @param recordId
     * @return
     */
    Object replayRequest(Long recordId);
}
```

```java
package com.yupi.springbootinit.example.interfaceaop.service.impl;

import cn.hutool.http.HttpRequest;
import cn.hutool.http.HttpResponse;
import cn.hutool.http.HttpUtil;
import cn.hutool.http.Method;
import cn.hutool.json.JSONObject;
import cn.hutool.json.JSONUtil;
import com.yupi.springbootinit.common.ErrorCode;
import com.yupi.springbootinit.example.interfaceaop.mapper.ApiRequestRecordMapper;
import com.yupi.springbootinit.example.interfaceaop.model.ApiRequestRecord;
import com.yupi.springbootinit.example.interfaceaop.service.ApiReplayService;
import com.yupi.springbootinit.exception.BusinessException;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.BeanUtils;
import org.springframework.stereotype.Service;
import org.springframework.util.StopWatch;

import javax.annotation.Resource;
import java.util.Date;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/23
 */

@Service
@Slf4j
public class ApiReplayServiceImpl implements ApiReplayService {

    @Resource
    private ApiRequestRecordMapper apiRequestRecordMapper;

    @Override
    public Object replayRequest(Long recordId) {
        // 获取历史请求记录
        ApiRequestRecord record = apiRequestRecordMapper.selectById(recordId);
        if (record == null) {
            throw new BusinessException(ErrorCode.NOT_FOUND_ERROR);
        }

        // 创建计时器
        StopWatch stopWatch = new StopWatch();

        try {
            stopWatch.start();
            // 创建请求对象
            HttpRequest request = createHttpRequest(record);

            // 设置 Content-Type
            String contentType = record.getContentType();
            if (StringUtils.isBlank(contentType)) {
                // 默认使用 application/json
                contentType = "application/json";
            }
            request.header("Content-Type", contentType);

            // 设置其他请求头
            if (StringUtils.isNotBlank(record.getHeaders())) {
                JSONObject headerJson = JSONUtil.parseObj(record.getHeaders());
                headerJson.forEach((key, value) -> {
                    if (!"content-length".equalsIgnoreCase(key)) {  // 跳过 content-length
                        request.header(key, String.valueOf(value));
                    }
                });
            }

            // 设置请求体
            if (StringUtils.isNotBlank(record.getRequestParams())) {
                if (StringUtils.containsIgnoreCase(contentType, "application/json")) {
                    // JSON 格式
                    request.body(record.getRequestParams());
                } else if (StringUtils.containsIgnoreCase(contentType, "application/x-www-form-urlencoded")) {
                    // 表单格式
                    JSONObject params = JSONUtil.parseObj(record.getRequestParams());
                    params.forEach((key, value) -> request.form(key, value));
                } else if (StringUtils.containsIgnoreCase(contentType, "multipart/form-data")) {
                    // 文件上传格式
                    JSONObject params = JSONUtil.parseObj(record.getRequestParams());
                    params.forEach((key, value) -> request.form(key, value));
                } else {
                    // 其他格式，直接设置为字符串
                    request.body(record.getRequestParams());
                }
            }

            // 执行请求
            HttpResponse response = request.execute();

            stopWatch.stop();

            // 保存重放结果
            ApiRequestRecord replayRecord = new ApiRequestRecord();
            BeanUtils.copyProperties(record, replayRecord);
            replayRecord.setId(null);
            replayRecord.setResponseData(response.body());
            replayRecord.setStatus(response.getStatus());
            replayRecord.setCreateTime(new Date());
            replayRecord.setTimeConsumed(stopWatch.getLastTaskTimeMillis());
            apiRequestRecordMapper.insert(replayRecord);

            return response.body();

        } catch (Exception e) {
            log.error("接口重放失败", e);
            throw new BusinessException(ErrorCode.SYSTEM_ERROR, "接口重放失败：" + e.getMessage());
        }
    }

    /**
     * 根据记录创建对应的 HttpRequest
     */
    private HttpRequest createHttpRequest(ApiRequestRecord record) {
        String method = record.getHttpMethod().toUpperCase();
        switch (method) {
            case "GET":
                return HttpUtil.createGet(record.getUrl());
            case "POST":
                return HttpUtil.createPost(record.getUrl());
            case "PUT":
                return HttpUtil.createRequest(Method.PUT, record.getUrl());
            case "DELETE":
                return HttpUtil.createRequest(Method.DELETE, record.getUrl());
            case "PATCH":
                return HttpUtil.createRequest(Method.PATCH, record.getUrl());
            case "HEAD":
                return HttpUtil.createRequest(Method.HEAD, record.getUrl());
            case "OPTIONS":
                return HttpUtil.createRequest(Method.OPTIONS, record.getUrl());
            default:
                throw new BusinessException(ErrorCode.PARAMS_ERROR, "不支持的 HTTP 方法：" + record.getHttpMethod());
        }
    }

}
```



### 日志注解

```java
package com.yupi.springbootinit.example.interfaceaop.annotation;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/23
 */
import java.lang.annotation.*;

/**
 * 接口日志注解
 */
@Target(ElementType.METHOD)  // 作用在方法上
@Retention(RetentionPolicy.RUNTIME)  // 运行时可见
@Documented  // 生成文档
public @interface ApiLog {
    /**
     * 接口描述
     */
    String value() default "";

    /**
     * 是否记录请求参数
     */
    boolean logParams() default true;

    /**
     * 是否记录响应结果
     */
    boolean logResponse() default true;
}
```

```java
package com.yupi.springbootinit.example.interfaceaop.aop;

import cn.hutool.json.JSONUtil;
import com.yupi.springbootinit.example.interfaceaop.mapper.ApiLogMapper;
import com.yupi.springbootinit.example.interfaceaop.model.ApiLog;
import com.yupi.springbootinit.model.entity.User;
import com.yupi.springbootinit.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import java.util.List;
import java.util.UUID;

import static com.yupi.springbootinit.utils.NetUtils.getIpAddress;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/23
 */
@Aspect
@Component
@Slf4j
public class ApiLogAspect {

    @Resource
    private ApiLogMapper apiLogMapper;

    @Resource
    private UserService userService;

    @Pointcut("@annotation(com.yupi.springbootinit.example.interfaceaop.annotation.ApiLog)")
    public void apiLogPointcut() {
    }

    @Around("apiLogPointcut()")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        long startTime = System.currentTimeMillis();
        String requestId = UUID.randomUUID().toString();

        // 获取请求信息
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();

        User loginUser = userService.getLoginUser(request);

        // 记录请求信息
        String url = request.getRequestURL().toString();
        String httpMethod = request.getMethod();
        String ip = getIpAddress(request);
        String classMethod = point.getSignature().getDeclaringTypeName() + "." + point.getSignature().getName();
        // 记录请求参数
        Object[] args = point.getArgs();
        String requestParams = null;
        if (args != null && args.length > 0) {
            // 检查参数类型并正确序列化
            if (args[0] instanceof List) {
                requestParams = JSONUtil.toJsonStr(args[0]);  // 数组格式
            } else {
                requestParams = JSONUtil.toJsonStr(args[0]);  // 对象格式
            }
        }

        // 执行目标方法
        Object result = null;
        try {
            result = point.proceed();
            return result;
        } finally {
            // 记录响应信息
            long endTime = System.currentTimeMillis();
            long timeConsumed = endTime - startTime;

            // 保存日志到数据库
            ApiLog apiLog = new ApiLog();
            apiLog.setRequestId(requestId);
            apiLog.setUrl(url);
            apiLog.setHttpMethod(httpMethod);
            apiLog.setIp(ip);
            apiLog.setClassMethod(classMethod);
            apiLog.setRequestParams(requestParams);
            apiLog.setResponseData(result != null ? JSONUtil.toJsonStr(result) : null);
            apiLog.setTimeConsumed(timeConsumed);
            apiLog.setUserId(String.valueOf(loginUser.getId()));

            apiLogMapper.insert(apiLog);
        }
    }
}
```



### 日志重放注解

```
package com.yupi.springbootinit.example.interfaceaop.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/23
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Replayable {
    String value() default "";  // 接口描述
}
```

```java
package com.yupi.springbootinit.example.interfaceaop.aop;

import cn.hutool.json.JSONUtil;
import com.yupi.springbootinit.example.interfaceaop.mapper.ApiRequestRecordMapper;
import com.yupi.springbootinit.example.interfaceaop.model.ApiRequestRecord;
import com.yupi.springbootinit.model.entity.User;
import com.yupi.springbootinit.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/23
 */
@Aspect
@Component
@Slf4j
public class ReplayableAspect {

    @Resource
    private ApiRequestRecordMapper apiRequestRecordMapper;

    @Resource
    private UserService userService;

    @Pointcut("@annotation(com.yupi.springbootinit.example.interfaceaop.annotation.Replayable)")
    public void replayablePointcut() {}

    @Around("replayablePointcut()")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        long startTime = System.currentTimeMillis();

        // 获取请求信息
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();

        User loginUser = userService.getLoginUser(request);

        // 记录请求信息
        ApiRequestRecord record = new ApiRequestRecord();
        record.setUrl(request.getRequestURL().toString());
        record.setHttpMethod(request.getMethod());
        record.setHeaders(getHeadersJson(request));
        record.setRequestParams(getRequestParams(request, point));
        record.setUserId(String.valueOf(loginUser.getId()));

        Object result = null;
        try {
            // 执行目标方法
            result = point.proceed();
            record.setStatus(200);
            record.setResponseData(JSONUtil.toJsonStr(result));
        } catch (Exception e) {
            record.setStatus(500);
            record.setResponseData(e.getMessage());
            throw e;
        } finally {
            // 记录耗时
            record.setTimeConsumed(System.currentTimeMillis() - startTime);
            // 保存记录
            apiRequestRecordMapper.insert(record);
        }

        return result;
    }

    private String getHeadersJson(HttpServletRequest request) {
        Map<String, String> headers = new HashMap<>();
        Enumeration<String> headerNames = request.getHeaderNames();
        while (headerNames.hasMoreElements()) {
            String headerName = headerNames.nextElement();
            headers.put(headerName, request.getHeader(headerName));
        }
        return JSONUtil.toJsonStr(headers);
    }

    private String getRequestParams(HttpServletRequest request, ProceedingJoinPoint point) {
        if ("POST".equalsIgnoreCase(request.getMethod())) {
            Object[] args = point.getArgs();
            // 如果只有一个参数，直接转换该参数对象
            if (args != null && args.length == 1) {
                return JSONUtil.toJsonStr(args[0]);
            }
            // 如果有多个参数，保持数组格式
            return JSONUtil.toJsonStr(args);
        } else {
            return JSONUtil.toJsonStr(request.getParameterMap());
        }
    }
}
```



### 控制层

```java
package com.yupi.springbootinit.example.interfaceaop.controller;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.yupi.springbootinit.common.BaseResponse;
import com.yupi.springbootinit.common.ResultUtils;
import com.yupi.springbootinit.example.interfaceaop.model.ApiRequestRecord;
import com.yupi.springbootinit.example.interfaceaop.service.ApiReplayService;
import com.yupi.springbootinit.example.interfaceaop.mapper.ApiRequestRecordMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.*;

import javax.annotation.Resource;
import java.util.List;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/23
 */
@RestController
@RequestMapping("/api/replay")
@Slf4j
public class ApiReplayController {

    @Resource
    private ApiReplayService apiReplayService;

    @Resource
    private ApiRequestRecordMapper apiRequestRecordMapper;

    @PostMapping("/execute")
    public BaseResponse<Object> replayRequest(@RequestParam Long recordId) {
        return ResultUtils.success(apiReplayService.replayRequest(recordId));
    }

    @GetMapping("/records")
    public BaseResponse<List<ApiRequestRecord>> getReplayableRecords() {
        LambdaQueryWrapper<ApiRequestRecord> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.orderByDesc(ApiRequestRecord::getCreateTime);
        return ResultUtils.success(apiRequestRecordMapper.selectList(queryWrapper));
    }
}
```



### 测试



#### 测试请求参数

```java
package com.yupi.springbootinit.example.interfaceaop.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.validation.constraints.Pattern;
import java.io.Serializable;
import java.util.Date;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/23
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TestRequest implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 名称
     */
    private String name;

    /**
     * 年龄
     */
    private Integer age;

    /**
     * 性别（0-男, 1-女）
     */
    private Integer gender;

    /**
     * 邮箱
     */
    @Pattern(regexp = "^[A-Za-z0-9+_.-]+@(.+)$", message = "邮箱格式不正确")
    private String email;

    /**
     * 手机号
     */
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    private String phone;

    /**
     * 创建时间
     */
    private Date createTime;

    /**
     * 更新时间
     */
    private Date updateTime;

    /**
     * 额外信息（JSON格式）
     */
    private String extraInfo;

    /**
     * 参数校验
     */
    private String content;
}
```

#### 测试控制层

```java
package com.yupi.springbootinit.example.interfaceaop.controller;

import com.yupi.springbootinit.common.BaseResponse;
import com.yupi.springbootinit.common.ResultUtils;
import com.yupi.springbootinit.example.interfaceaop.annotation.ApiLog;
import com.yupi.springbootinit.example.interfaceaop.annotation.Replayable;
import com.yupi.springbootinit.example.interfaceaop.model.TestRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/23
 */
@RestController
@RequestMapping("/api")
@Slf4j
public class TestController {

    @Replayable("可重放的测试接口")
    @ApiLog
    @PostMapping("/test")
    public BaseResponse<String> test(@RequestBody TestRequest request) {
        // 业务逻辑
        log.info("收到请求: {}", request);
        return ResultUtils.success("ok");
    }

}
```



执行testcontroller.test

![image-20241223200042087](https://note-1259190304.cos.ap-chengdu.myqcloud.com/noteimage-20241223200042087.png)

日志表有信息

![image-20241223200102073](https://note-1259190304.cos.ap-chengdu.myqcloud.com/noteimage-20241223200102073.png)

重发接口信息表

![image-20241223200133212](https://note-1259190304.cos.ap-chengdu.myqcloud.com/noteimage-20241223200133212.png)



查询最近的接口信息

![image-20241223200159211](https://note-1259190304.cos.ap-chengdu.myqcloud.com/noteimage-20241223200159211.png)

```
```

测试重发接口

![image-20241223200225474](https://note-1259190304.cos.ap-chengdu.myqcloud.com/noteimage-20241223200225474.png)

调用成功

![image-20241223200320529](https://note-1259190304.cos.ap-chengdu.myqcloud.com/noteimage-20241223200320529.png)

![image-20241223200243935](https://note-1259190304.cos.ap-chengdu.myqcloud.com/noteimage-20241223200243935.png)





## callback



使用反射(可使用jdk或cglib代理) + transactionTemplate事务管理 + ServiceUtils.commonExec统一的service入口

> 选择建议：
>
> 如果目标类有接口，优先使用JDK动态代理
>
> 符合面向接口编程原则
>
> 代理生成速度快
>
> 内存占用少
>
> 
>
> 如果目标类没有接口，使用CGLIB代理
>
> 运行时性能好
>
> 不需要额外定义接口
>
> 
>
> 特殊情况考虑：
>
> 如果对性能要求特别高，可以考虑CGLIB
>
> 如果内存资源紧张，建议JDK动态代理
>
> 如果类有final方法，必须用JDK动态代理

### sql语句

```mysql
CREATE TABLE service_processor_config (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    serviceName VARCHAR(100) NOT NULL COMMENT '服务名称',
    methodName VARCHAR(100) NOT NULL COMMENT '方法名称',
    processorName VARCHAR(100) NOT NULL COMMENT '处理器名称',
    timing VARCHAR(10) NOT NULL COMMENT '执行时机(before/after)',
    isAsync TINYINT(1) NOT NULL DEFAULT 0 COMMENT '是否异步(0-同步,1-异步)',
    ignoreError TINYINT(1) NOT NULL DEFAULT 1 COMMENT '是否忽略错误(0-不忽略,1-忽略)',
    status TINYINT(1) NOT NULL DEFAULT 1 COMMENT '是否启用(0-禁用,1-启用)',
    createTime DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updateTime DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    isDelete TINYINT NOT NULL DEFAULT 0 COMMENT '是否删除'
) COMMENT '服务处理器配置表';
INSERT INTO service_processor_config
(serviceName, methodName, processorName, timing, isAsync, ignoreError, status)
VALUES
('testService', 'testParameters', 'testNotReturnCallback', 'before', 1, 1, 1);
INSERT INTO service_processor_config
(serviceName, methodName, processorName, timing, isAsync, ignoreError, status)
VALUES
('testService', 'testNotReturn', 'testNotReturnCallback', 'before', 1, 1, 1);
```

### 请求参数

```java
package com.yupi.springbootinit.example.commonserviceExec.model.dto;

import lombok.Data;

import javax.validation.constraints.NotBlank;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/24
 */
@Data
public class CommonServiceRequest<T> {
    /**
     * 服务名称 (例如: "userService")
     */
    @NotBlank(message = "服务名称不能为空")
    private String serviceName;

    /**
     * 方法名称
     */
    @NotBlank(message = "方法名称不能为空")
    private String methodName;

    /**
     * 方法参数
     */
    private T requestData;
}
```

### 调用方法参数实体

```java
package com.yupi.springbootinit.example.commonserviceExec.model.entity;

import com.baomidou.mybatisplus.annotation.*;
import lombok.Data;

import java.util.Date;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/24
 */
@Data
@TableName("service_processor_config")
public class ServiceProcessorConfig {

    @TableId(type = IdType.AUTO)
    private Long id;

   
    private String serviceName;

   
    private String methodName;

   
    private String processorName;

   
    private String timing;

   
    private Boolean isAsync;

   
    private Boolean ignoreError;

   
    private Boolean status;

   
    private Date createTime;

   
    private Date updateTime;

    /**
     * 是否删除
     */
    @TableLogic
    private Integer isDelete;

    @TableField(exist = false)
    private static final long serialVersionUID = 1L;
}
```

### 配置信息mapper

```java
package com.yupi.springbootinit.example.commonserviceExec.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.yupi.springbootinit.example.commonserviceExec.model.entity.ServiceProcessorConfig;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface ServiceProcessorConfigMapper extends BaseMapper<ServiceProcessorConfig> {
}
```



### 获取配置信息service

```java
package com.yupi.springbootinit.example.commonserviceExec.service;


import com.yupi.springbootinit.example.commonserviceExec.model.entity.ServiceProcessorConfig;

import java.util.List;

/**
 * @author tuaofei
 * @description 处理器配置服务
 * @date 2024/12/24
 */
public interface ProcessorConfigService {

    List<ServiceProcessorConfig> getConfigs(String serviceName, String methodName);
}
```

```java
package com.yupi.springbootinit.example.commonserviceExec.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.yupi.springbootinit.example.commonserviceExec.mapper.ServiceProcessorConfigMapper;
import com.yupi.springbootinit.example.commonserviceExec.model.entity.ServiceProcessorConfig;
import com.yupi.springbootinit.example.commonserviceExec.service.ProcessorConfigService;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;
import java.util.List;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/24
 */
@Service
public class ProcessorConfigServiceImpl implements ProcessorConfigService {

    @Resource
    private ServiceProcessorConfigMapper configMapper;

    @Override
    public List<ServiceProcessorConfig> getConfigs(String serviceName, String methodName) {
        return configMapper.selectList(new QueryWrapper<ServiceProcessorConfig>()
                .eq("serviceName", serviceName)
                .eq("methodName", methodName)
                .eq("status", true));
    }
}
```



### 处理器接口

```java
package com.yupi.springbootinit.example.commonserviceExec.service;

import com.yupi.springbootinit.common.BaseResponse;
import com.yupi.springbootinit.example.commonserviceExec.model.dto.CommonServiceRequest;

/**
 * @author tuaofei
 * @description 处理器接口
 * @date 2024/12/24
 */
public interface ServiceProcessor {

    /**
     * 处理方法
     */
    void process(String serviceName, String methodName,
                 CommonServiceRequest<?> request, BaseResponse<?> response);
}
```

### 工具类

```java
package com.yupi.springbootinit.example.commonserviceExec.utils;

import com.yupi.springbootinit.common.BaseResponse;
import com.yupi.springbootinit.common.ErrorCode;
import com.yupi.springbootinit.common.ResultUtils;
import com.yupi.springbootinit.example.commonserviceExec.model.dto.CommonServiceRequest;
import com.yupi.springbootinit.example.commonserviceExec.model.entity.ServiceProcessorConfig;
import com.yupi.springbootinit.example.commonserviceExec.service.ProcessorConfigService;
import com.yupi.springbootinit.example.commonserviceExec.service.ServiceProcessor;
import com.yupi.springbootinit.exception.BusinessException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.stereotype.Component;
import org.springframework.transaction.support.TransactionTemplate;

import javax.annotation.Resource;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/24
 */
@Component
@Slf4j
public class ServiceUtils implements ApplicationContextAware {


    private static ThreadPoolTaskExecutor taskExecutor;


    private static TransactionTemplate transactionTemplate;


    private static ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext context) throws BeansException {
        applicationContext = context;
    }

    @Resource
    public void setTransactionTemplate(TransactionTemplate transactionTemplate) {
        ServiceUtils.transactionTemplate = transactionTemplate;
    }

    @Resource
    public void setTaskExecutor(ThreadPoolTaskExecutor taskExecutor) {
        ServiceUtils.taskExecutor = taskExecutor;
    }

    /**
     * 通用服务方法执行
     *
     * @param request 请求参数
     * @return 执行结果
     */
    @SuppressWarnings("unchecked")
    public static <T> BaseResponse<T> commonExec(CommonServiceRequest<?> request) {
        return transactionTemplate.execute(status -> {
            try {
                String serviceName = request.getServiceName();
                String methodName = request.getMethodName();

                // 获取处理器配置
                ProcessorConfigService configService = applicationContext.getBean(ProcessorConfigService.class);
                List<ServiceProcessorConfig> configs = configService.getConfigs(serviceName, methodName);

                // 1. 获取服务实例
                Object service = applicationContext.getBean(serviceName);

                // 2. 获取方法
                Method method = service.getClass().getMethod(methodName,
                        CommonServiceRequest.class, BaseResponse.class);

                // 3. 创建响应对象
                BaseResponse<T> response = new BaseResponse<>(ErrorCode.SUCCESS);

                // 执行前置处理器
                executeProcessors(configs, "before", serviceName, methodName, request, response);

                // 4. 执行方法
                Object result = method.invoke(service, request, response);

                // 执行后置处理器
                executeProcessors(configs, "after", serviceName, methodName, request, response);

                return ResultUtils.success((T) result);
            } catch (Exception e) {
                log.error("Service execution error", e);
                status.setRollbackOnly();
                return ResultUtils.error(ErrorCode.SYSTEM_ERROR, e.getMessage());
            }
        });
    }

    public static void executeProcessors(List<ServiceProcessorConfig> configs, String timing,
                                         String serviceName, String methodName,
                                         CommonServiceRequest<?> request,
                                         BaseResponse<?> response) {
        List<CompletableFuture<Void>> futures = new ArrayList<>();

        for (ServiceProcessorConfig config : configs) {
            if (!config.getTiming().equals(timing)) {
                continue;
            }

            ServiceProcessor processor = applicationContext.getBean(config.getProcessorName(), ServiceProcessor.class);

            if (config.getIsAsync()) {
                // 异步执行
                CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                    try {
                        // 在新的事务中执行处理器
                        transactionTemplate.execute(processorStatus -> {
                            try {
                                processor.process(serviceName, methodName, request, response);
                                return null;
                            } catch (Exception e) {
                                if (!config.getIgnoreError()) {
                                    // 如果不忽略异常，设置事务回滚并抛出异常
                                    processorStatus.setRollbackOnly();
                                    throw new BusinessException(ErrorCode.SYSTEM_ERROR, e.getMessage());
                                }
                                // 如果忽略异常，只记录日志
                                log.error("Async processor execution error", e);
                                return null;
                            }
                        });
                    } catch (Exception e) {
                        if (!config.getIgnoreError()) {
                            // 外层异常处理，如果不忽略异常则抛出
                            throw new BusinessException(ErrorCode.SYSTEM_ERROR, e.getMessage());
                        }
                        log.error("Async processor execution error", e);
                    }
                }, taskExecutor);

                futures.add(future);
            } else {
                // 同步执行
                try {
                    processor.process(serviceName, methodName, request, response);
                } catch (Exception e) {
                    if (!config.getIgnoreError()) {
                        throw new BusinessException(ErrorCode.SYSTEM_ERROR, e.getMessage());
                    }
                    log.error("Sync processor execution error", e);
                }
            }
        }

        // 等待所有异步任务完成
        if (!futures.isEmpty()) {
            try {
                CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                        .get(30, TimeUnit.SECONDS);
            } catch (InterruptedException | ExecutionException | TimeoutException e) {
                throw new BusinessException(ErrorCode.SYSTEM_ERROR, e.getMessage());
            }
        }
    }

}
```

### 具体service的callback

```java
package com.yupi.springbootinit.example.commonserviceExec.service.impl;

import com.yupi.springbootinit.common.BaseResponse;
import com.yupi.springbootinit.example.commonserviceExec.model.dto.CommonServiceRequest;
import com.yupi.springbootinit.example.commonserviceExec.service.ServiceProcessor;
import com.yupi.springbootinit.model.entity.User;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/24
 */
@Slf4j
@Component("TestParametersCallback")
public class TestParametersCallback implements ServiceProcessor {

    @Override
    public void process(String serviceName, String methodName,
                        CommonServiceRequest<?> request, BaseResponse<?> response) {
        log.info("Service: {}, Method: {}, Request: {}, Response: {}",
                serviceName, methodName, request, response);
        Object requestData = request.getRequestData();
        if (requestData instanceof User) {
            int i = 1 / 0;
            log.info("模拟执行 testNotReturnCallback ，参数：{}", requestData);
        }
    }
}
```

```java
package com.yupi.springbootinit.example.commonserviceExec.service.impl;

import com.yupi.springbootinit.common.BaseResponse;
import com.yupi.springbootinit.example.commonserviceExec.model.dto.CommonServiceRequest;
import com.yupi.springbootinit.example.commonserviceExec.service.ServiceProcessor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/24
 */
@Slf4j
@Component("testNotReturnCallback")
public class testNotReturnCallback implements ServiceProcessor {

    @Override
    public void process(String serviceName, String methodName,
                        CommonServiceRequest<?> request, BaseResponse<?> response) {
        log.info("Service: {}, Method: {}, Request: {}, Response: {}",
                serviceName, methodName, request, response);
        int i = 1 / 0;
        log.info("模拟执行 {testNotReturnCallback}");
    }
}
```

### 测试service实现类

```java
package com.yupi.springbootinit.example.commonserviceExec.service;

import com.yupi.springbootinit.common.BaseResponse;
import com.yupi.springbootinit.example.commonserviceExec.model.dto.CommonServiceRequest;
import com.yupi.springbootinit.model.entity.User;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/24
 */
public interface TestService {

    void testNotReturn(CommonServiceRequest request, BaseResponse response);

    BaseResponse<User> testParameters(CommonServiceRequest<User> request, BaseResponse<User> response);
}
```

```java
package com.yupi.springbootinit.example.commonserviceExec.service.impl;

import com.yupi.springbootinit.common.BaseResponse;
import com.yupi.springbootinit.common.ResultUtils;
import com.yupi.springbootinit.example.commonserviceExec.model.dto.CommonServiceRequest;
import com.yupi.springbootinit.example.commonserviceExec.service.TestService;
import com.yupi.springbootinit.model.entity.User;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/24
 */
@Service("testService")
@Slf4j
public class TestServiceImpl implements TestService {
    @Override
    public void testNotReturn(CommonServiceRequest request, BaseResponse response) {
        log.info("exec testNotReturn");
    }

    @Override
    public BaseResponse<User> testParameters(CommonServiceRequest<User> request, BaseResponse<User> response) {
        log.info("exec testParameters");

        User user = request.getRequestData();
        user.setUserName("xiaofei");
        return ResultUtils.success(user);
    }
}
```

### 测试controller

```java
package com.yupi.springbootinit.example.commonserviceExec.controller;

import com.yupi.springbootinit.common.BaseResponse;
import com.yupi.springbootinit.example.commonserviceExec.model.dto.CommonServiceRequest;
import com.yupi.springbootinit.example.commonserviceExec.utils.ServiceUtils;
import com.yupi.springbootinit.model.entity.User;
import org.apache.poi.ss.formula.functions.T;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/24
 */
@RestController("service")
@RequestMapping("/common/service")
public class TestController {

    @PostMapping("/exec")
    public BaseResponse<T> commonExec(@RequestBody CommonServiceRequest request) {
        return ServiceUtils.commonExec(request);
    }

    @PostMapping("/textExec")
    public BaseResponse<T> textExec() {
        CommonServiceRequest serviceRequest = new CommonServiceRequest();
        serviceRequest.setServiceName("testService");
        serviceRequest.setMethodName("testNotReturn");
        return commonExec(serviceRequest);
    }

    @PostMapping("/testParametersExec")
    public BaseResponse<T> testParametersExec() {
        User user = new User();
        CommonServiceRequest serviceRequest = new CommonServiceRequest();
        serviceRequest.setServiceName("testService");
        serviceRequest.setMethodName("testParameters");
        serviceRequest.setRequestData(user);
        return commonExec(serviceRequest);
    }

}
```

可配置测试信息

![image-20241224115154860](https://note-1259190304.cos.ap-chengdu.myqcloud.com/noteimage-20241224115154860.png)

测试异步执行，执行时机在方法之前，不忽略异常，主线程是否中断

测试异步执行，执行时机在方法之前，忽略异常，主线程是否中断





## 多数据源管理

继承 AbstractRoutingDataSource 抽象类

### application.yml配置

```yml
spring:   
  datasource:
    master:
      jdbc-url: jdbc:mysql://localhost:3306/my_db?serverTimezone=Asia/Shanghai
      driver-class-name: com.mysql.cj.jdbc.Driver
      username: root
      password: root
    lovefinder:
      jdbc-url: jdbc:mysql://localhost:3306/lovefinder?serverTimezone=Asia/Shanghai
      driver-class-name: com.mysql.cj.jdbc.Driver
      username: root
      password: root
```

### 数据源类型枚举

```java
package com.yupi.springbootinit.config.datasource;

/**
 * @author tuaofei
 * @description 数据源类型枚举
 * @date 2024/12/24
 */
public enum DataSourceType {
    MASTER,
    LOVEFINDER
}
```

### 数据源配置类

```java
package com.yupi.springbootinit.config.datasource;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

/**
 * @author tuaofei
 * @description 数据源配置类
 * @date 2024/12/24
 */
@Configuration
public class DataSourceConfig {

    @Bean
    @ConfigurationProperties("spring.datasource.master")
    public DataSource masterDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @ConfigurationProperties("spring.datasource.lovefinder")
    public DataSource lovefinderDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @Primary
    public DataSource dynamicDataSource() {
        Map<Object, Object> targetDataSources = new HashMap<>(2);
        targetDataSources.put(DataSourceType.MASTER.name(), masterDataSource());
        targetDataSources.put(DataSourceType.LOVEFINDER.name(), lovefinderDataSource());

        return new DynamicDataSource(masterDataSource(), targetDataSources);
    }
}
```

### 动态数据源实现

```java
package com.yupi.springbootinit.config.datasource;

import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;

import javax.sql.DataSource;
import java.util.Map;

/**
 * @author tuaofei
 * @description 动态数据源实现
 * @date 2024/12/24
 */
public class DynamicDataSource extends AbstractRoutingDataSource {
    /**
     * 构造方法，初始化动态数据源
     *
     * @param defaultTargetDataSource 默认数据源
     * @param targetDataSources       目标数据源集合
     */
    public DynamicDataSource(DataSource defaultTargetDataSource, Map<Object, Object> targetDataSources) {
        // 设置默认数据源
        super.setDefaultTargetDataSource(defaultTargetDataSource);
        // 设置数据源集合
        super.setTargetDataSources(targetDataSources);
        // 执行afterPropertiesSet方法，完成属性初始化
        super.afterPropertiesSet();
    }

    /**
     * 获取当前数据源的key
     *
     * @return 数据源key
     */
    @Override
    protected Object determineCurrentLookupKey() {
        // 从ThreadLocal中获取当前数据源的key
        return DataSourceContextHolder.getDataSource();
    }
}
```

### 数据源上下文

```java
package com.yupi.springbootinit.config.datasource;

/**
 * @author tuaofei
 * @description 数据源上下文
 * @date 2024/12/24
 */
public class DataSourceContextHolder {
    /**
     * 使用ThreadLocal存储当前线程的数据源key
     */
    private static final ThreadLocal<String> CONTEXT_HOLDER = new ThreadLocal<>();

    /**
     * 设置数据源
     *
     * @param dataSourceType 数据源类型
     */
    public static void setDataSource(DataSourceType dataSourceType) {
        CONTEXT_HOLDER.set(dataSourceType.name());
    }

    /**
     * 获取数据源
     *
     * @return 数据源key
     */
    public static String getDataSource() {
        return CONTEXT_HOLDER.get();
    }

    /**
     * 清除数据源
     */
    public static void clearDataSource() {
        CONTEXT_HOLDER.remove();
    }
}
```

### MyBatis Plus 配置

```java
package com.yupi.springbootinit.config;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

import javax.annotation.Resource;
import javax.sql.DataSource;

/**
 * MyBatis Plus 配置
 */
@Configuration
@MapperScan("com.yupi.springbootinit.mapper")
public class MyBatisPlusConfig {

    @Resource(name = "dynamicDataSource")
    private DataSource dynamicDataSource;

    @Bean
    public PlatformTransactionManager transactionManager() {
        return new DataSourceTransactionManager(dynamicDataSource);
    }
}
```

### 数据源切换切面

```java
package com.yupi.springbootinit.aop;

import com.yupi.springbootinit.annotation.DataSource;
import com.yupi.springbootinit.config.datasource.DataSourceContextHolder;
import com.yupi.springbootinit.config.datasource.DataSourceType;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

/**
 * @author tuaofei
 * @description 数据源切换切面
 * @date 2024/12/24
 */
@Slf4j
@Aspect
@Component
public class DataSourceAspect {

    @Pointcut("@annotation(com.yupi.springbootinit.annotation.DataSource)")
    public void apiLogPointcut() {
    }

    @Around("apiLogPointcut()")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        MethodSignature signature = (MethodSignature) point.getSignature();
        DataSource dataSource = signature.getMethod().getAnnotation(DataSource.class);
        if (dataSource != null) {
            DataSourceType dataSourceType = dataSource.value();
            log.info("切换数据源到: {}", dataSourceType);
            DataSourceContextHolder.setDataSource(dataSourceType);
        }

        try {
            return point.proceed();
        } finally {
            log.info("清除数据源配置");
            DataSourceContextHolder.clearDataSource();
        }
    }
}
```

### 数据源切换注解

```java
package com.yupi.springbootinit.annotation;

import com.yupi.springbootinit.config.datasource.DataSourceType;

import java.lang.annotation.*;

/**
 * @author tuaofei
 * @description 数据源切换注解
 * @date 2024/12/24
 */
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DataSource {
    DataSourceType value() default DataSourceType.MASTER;
}
```

### service测试

```java
package com.yupi.springbootinit.service;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.service.IService;
import com.yupi.springbootinit.annotation.DataSource;
import com.yupi.springbootinit.config.datasource.DataSourceType;
import com.yupi.springbootinit.model.dto.user.UserQueryRequest;
import com.yupi.springbootinit.model.entity.User;
import com.yupi.springbootinit.model.vo.LoginUserVO;
import com.yupi.springbootinit.model.vo.UserVO;
import java.util.List;
import javax.servlet.http.HttpServletRequest;
import me.chanjar.weixin.common.bean.WxOAuth2UserInfo;

/**
 * 用户服务
 *
 * @author <a href="https://github.com/liyupi">程序员鱼皮</a>
 * @from <a href="https://yupi.icu">编程导航知识星球</a>
 */
public interface UserService extends IService<User> {

    /**
     * 同步用户数据（主库->从库）
     * @return
     */
    boolean synchronizationUser();

    /**
     * 执行插入操作，向主库和从库
     * @return
     */
    boolean execInsert();

    /**
     * 查询最新的用户
     * @return
     */
    User queryLastNewUser();

}
```

```java
package com.yupi.springbootinit.service.impl;

import static com.yupi.springbootinit.constant.UserConstant.USER_LOGIN_STATE;

import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.collection.CollectionUtil;
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.yupi.springbootinit.annotation.DataSource;
import com.yupi.springbootinit.common.ErrorCode;
import com.yupi.springbootinit.config.datasource.DataSourceContextHolder;
import com.yupi.springbootinit.config.datasource.DataSourceType;
import com.yupi.springbootinit.constant.CommonConstant;
import com.yupi.springbootinit.exception.BusinessException;
import com.yupi.springbootinit.mapper.UserMapper;
import com.yupi.springbootinit.model.dto.user.UserQueryRequest;
import com.yupi.springbootinit.model.entity.User;
import com.yupi.springbootinit.model.enums.UserRoleEnum;
import com.yupi.springbootinit.model.vo.LoginUserVO;
import com.yupi.springbootinit.model.vo.UserVO;
import com.yupi.springbootinit.service.UserService;
import com.yupi.springbootinit.utils.SqlUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;

import lombok.extern.slf4j.Slf4j;
import me.chanjar.weixin.common.bean.WxOAuth2UserInfo;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.BeanUtils;
import org.springframework.stereotype.Service;
import org.springframework.util.DigestUtils;

/**
 * 用户服务实现
 *
 * @author <a href="https://github.com/liyupi">程序员鱼皮</a>
 * @from <a href="https://yupi.icu">编程导航知识星球</a>
 */
@Service
@Slf4j
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {

    @Override
    public boolean synchronizationUser() {
        try {
            DataSourceContextHolder.setDataSource(DataSourceType.MASTER);
            QueryWrapper<User> wrapper = new QueryWrapper<>();
            List<User> userPoList = list(wrapper);
            if (CollectionUtil.isEmpty(userPoList)) {
                log.info("主库无数据!");
                return false;
            }

            DataSourceContextHolder.setDataSource(DataSourceType.LOVEFINDER);
            boolean savedBatch = saveBatch(userPoList);
            return savedBatch;

        } finally {
            DataSourceContextHolder.clearDataSource();
        }
    }

    @Override
    public boolean execInsert() {
        User user = queryLastNewUser();

        if (user != null){
            user.setId(null);
        }

        boolean save = save(user);

//        int i = 1/0;

        return save;
    }

    @Override
    @DataSource(DataSourceType.LOVEFINDER)
    public User queryLastNewUser() {
        Page<User> page = new Page<>(1, 1);
        QueryWrapper<User> wrapper = new QueryWrapper<>();
        wrapper.orderByDesc("createTime");
        Page<User> userPage = userMapper.selectPage(page, wrapper);
        List<User> records = userPage.getRecords();
        return records.get(0);
    }
}
```

### Controller测试

```java
package com.yupi.springbootinit.example.datasource.controller;

import com.yupi.springbootinit.common.BaseResponse;
import com.yupi.springbootinit.common.ErrorCode;
import com.yupi.springbootinit.common.ResultUtils;
import com.yupi.springbootinit.model.entity.User;
import com.yupi.springbootinit.service.impl.UserServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author tuaofei
 * @description TODO
 * @date 2024/12/24
 */
@RestController("dataSource")
@RequestMapping("/dataSource")
public class DataSourceController {

    @Autowired
    private UserServiceImpl userService;

    @PostMapping("/test1")
    public BaseResponse<String> test1() {
        boolean save = userService.synchronizationUser();
        if (save) {
            return ResultUtils.success("插入成功");
        }
        return ResultUtils.error(ErrorCode.SYSTEM_ERROR, "插入失败");
    }

    @PostMapping("/test2")
    public BaseResponse<String> test2() {
        boolean insert = userService.execInsert();
        if (insert) {
            return ResultUtils.success("插入成功");
        }
        return ResultUtils.error(ErrorCode.SYSTEM_ERROR, "插入失败");
    }

    @PostMapping("/test3")
    public BaseResponse<User> test3() {
        User user = userService.queryLastNewUser();
        if (user != null) {
            return ResultUtils.success(user);
        }
        return ResultUtils.error(ErrorCode.SYSTEM_ERROR, "查询失败");
    }

}
```



### 失效场景

```java
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {
    
    // 这种情况下，@DataSource 注解不会生效，因为是类内部调用
    public void methodA() {
        methodB();  // 直接调用不会触发AOP
    }
    
    @DataSource(DataSourceType.LOVEFINDER)
    public void methodB() {
        // ...
    }
    
    // 解决方案1：使用AopContext获取代理对象
    public void methodA() {
        ((UserServiceImpl) AopContext.currentProxy()).methodB();
    }
    
    // 解决方案2：注入自己
    @Resource
    private UserService userService;  // 注入接口而不是实现类
    
    public void methodA() {
        userService.methodB();  // 通过代理对象调用
    }
}
```



## 接口调用-签名认证-AK/SK

### AK/SK认证机制概述

AK (Access Key): 访问标识，相当于用户名

SK (Secret Key): 密钥，用于生成签名的密钥，必须保密

```
// 1. 获取请求头中的关键参数
String accessKey = headers.getFirst("accessKey");    // 访问密钥
String secretKey = user.getSecretKey();             // 密钥(从用户信息中获取)
String timestamp = headers.getFirst("timestamp");    // 时间戳
String sign = headers.getFirst("sign");             // 请求签名
String body = headers.getFirst("body");             // 请求体
```

accessKey/secretKey创建用户时生成：

```java
/**
* Return a hexadecimal string representation of the MD5 digest of the given bytes.
* @param bytes the bytes to calculate the digest over
* @return a hexadecimal digest string
*/
public static String md5DigestAsHex(byte[] bytes) {
	return digestAsHexString(MD5_ALGORITHM_NAME, bytes);
}
/**
* 盐值，混淆密码
*/
String SALT = "api";
/**
* ak/sk 混淆
*/
String VOUCHER = "accessKey_secretKey";
// ak/sk
String accessKey = DigestUtils.md5DigestAsHex((userAccount + UserConstant.SALT + UserConstant.VOUCHER).getBytes());
String secretKey = DigestUtils.md5DigestAsHex((UserConstant.SALT + UserConstant.VOUCHER + userAccount).getBytes());
```



### 安全校验步骤

#### 1.参数完整性校验

```java
if (StringUtils.isAnyBlank(body, sign, accessKey, timestamp)) {
    throw new BusinessException(ResponseCode.FORBIDDEN_ERROR);
}
```

#### 2.防重放攻击

```java
/**
 * 五分钟过期时间
*/
private static final long FIVE_MINUTES = 5L * 60;
long currentTime = System.currentTimeMillis() / 1000;
if (currentTime - Long.parseLong(timestamp) >= FIVE_MINUTES) {
    throw new BusinessException(ResponseCode.NOT_LOGIN_ERROR, "会话已过期,请重试！");
}
```

#### 3.AK验证

```java
//通过访问密钥获取用户信息
user = dubboUserService.getInvokeUserByAccessKey(accessKey);
if (!user.getAccessKey().equals(accessKey)) {
    throw new BusinessException(ResponseCode.NO_AUTH_ERROR, "请先获取请求密钥");
}
```

#### 4.签名验证

```java
public static String getSign(String body, String secretKey) {
	return MD5.create().digestHex(JSONUtil.toJsonStr(body) + '.' + secretKey);
}
if (!SignUtil.getSign(body, user.getSecretKey()).equals(sign)) {
    throw new BusinessException(ResponseCode.NO_AUTH_ERROR, "非法请求");
}
```

### 签名生成原理

1. 客户端使用相同的算法，用 body 和 SK 生成签名

2. 服务端用相同的参数和算法生成签名，与客户端传来的签名比对

3. 签名一致才说明：

​	请求确实来自持有正确 SK 的客户端

​	请求参数在传输过程中未被篡改



### 安全特点

防篡改：任何参数被修改都会导致签名验证失败

防重放：使用时间戳确保请求的时效性

身份认证：通过 AK/SK 确保调用者身份

密钥安全：SK 不在网络传输，只用于本地签名



### 最佳实践

SK 必须妥善保管，不能泄露

时间戳应使用标准时间

签名算法要足够安全（通常使用 HMAC-SHA256 等）

关键操作要使用 HTTPS
