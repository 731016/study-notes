## 为什么要重写hashcode

hashcode默认计算对象的hashcode，如果两个对象地址不同，内容相同。计算的两个hash值是不同的，为了避免这种情况需要重写hashcode

equals默认也是对象的引用地址，重写后比较对象的值
所以，我们一般会在使用hashmap存储数据时，让equals和hashcode的值保持一致

> 继承comparable接口 实现compareTo(<E> o)方法
>
> 匿名内部类实现compartor接口，实现compare(<E> o1,<E> o2)方法

```java
public class Student implements Comparable<Student> {
    private String name;
    private Integer age;
    private Double mathScore;
    private Double englishScore;

    @Override
    public boolean equals(Object o) {
        //如果是同一个对象返回true，反之返回false
        if (this == o) return true;
        //判断是否类型相同
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return Objects.equals(name, student.name) &&
                Objects.equals(age, student.age) &&
                Objects.equals(mathScore, student.mathScore) &&
                Objects.equals(englishScore, student.englishScore);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age, mathScore, englishScore);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Double getMathScore() {
        return mathScore;
    }

    public void setMathScore(Double mathScore) {
        this.mathScore = mathScore;
    }

    public Double getEnglishScore() {
        return englishScore;
    }

    public void setEnglishScore(Double englishScore) {
        this.englishScore = englishScore;
    }

    public Student() {
    }

    public Student(String name, Integer age, Double mathScore, Double englishScore) {
        this.name = name;
        this.age = age;
        this.mathScore = mathScore;
        this.englishScore = englishScore;
    }

    /*
     * description: 自定义比较，先比较数学成绩，再比较英语成绩，再比较年龄
     * @Param: [s] 
     * @Return: int 
     **/
    @Override
    public int compareTo(Student s) {
        if(!mathScore.equals(s.mathScore)){
            return -(int) (mathScore-s.mathScore);
        }else if(!englishScore.equals(s.englishScore)){
            return -(int)(englishScore-s.englishScore);
        }else {
            return s.age-age;
        }
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", mathScore=" + mathScore +
                ", englishScore=" + englishScore +
                '}';
    }
}
```

```java
public static void main(String[] args) {

        Student stu1 = new Student("胡梓卓1", 22, 89.5, 88.6);
        Student stu2 = new Student("胡梓卓2", 22, 68.0, 16.0);
        Student stu3 = new Student("胡梓卓3", 21, 68.0, 25.0);
        List<Student> list = new ArrayList<>();
        list.add(stu1);
        list.add(stu2);
        list.add(stu3);
        Collections.sort(list,(student1,student2)->{
            if(!student1.getMathScore().equals(student2.getMathScore())){
                return (int) (student2.getMathScore()-student1.getMathScore());
            }else if(!student1.getEnglishScore().equals(student2.getEnglishScore())){
                return (int)(student2.getEnglishScore()-student1.getEnglishScore());
            }else {
                return student2.getAge()-student1.getAge();
            }
        });
        list.forEach(System.out ::println);
    }
```



## ArrayList在什么情况下比LinkedList插入快



## 数据库索引是什么



## 自定义对象多条件排序



## git命令



## 上传冲突怎么解决



## 暂存区作用

