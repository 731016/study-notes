#### 原文链接：[Java基础面试16问](https://mp.weixin.qq.com/s/-xFSHf7Gz3FUcafTJUIGWQ)

## 说说进程和线程的区别？

进程是**程序的一次执行**，是**系统资源分配与调动的基本单位**，使程序能够**并发执行**

因为进程的创建、销毁、切换产生大量的时间和空间开销，进程的数量不能太多，线程是比**进程更小的能独立运行的基本单位，是进程的一个实体**

线程基本占用系统资源，只运行必不可少的资源（程序计数器，寄存器，栈）

进程占用堆、栈



## 知道synchronized原理吗？

java提供的**原子性内置锁🔒**，内置的使用者看不到的锁称为**监视器锁**，使用synchronized之后，会在编译之后在同步的代码块前后加上`monitorenter`和

`monitorexit`字节码指令,它依赖操作系统底层互斥锁实现。它的作用主要是实现原子性操作和解决共享变量的内存可见性问题。

执行`monitorenter`指令时会**尝试获取对象锁**，如果**对象没有被锁定或者已经获得了锁**，<u>锁的计数器+1</u>.此时其他竞争锁的线程会**进入等待队列**中。

执行`monitorexit`指令时会把<u>计数器-1</u>，当计数器为0时，锁释放，处于等待队列中的线程再继续竞争锁。

synchronized是排它锁，当一个线程获得锁之后，其他线程必须等待该线程释放锁后才能获得锁。



## 对于加锁，那再说下ReentrantLock原理？他和synchronized有什么区别？

ReentrantLock需要**显式的获取锁和释放锁**

1. **等待可中断**，当持有锁的线程长时间不释放锁的时候，等待中的线程可以选择放弃等待，转而处理其他的任务。

2. **公平锁**：`synchronized`和`ReentrantLock`默认都是非公平锁，但是ReentrantLock可以通过构造函数传参改变。只不过使用公平锁的话会导致性能急剧下降。

   ```java
   public ReentrantLock(boolean fair) {
           sync = fair ? new FairSync() : new NonfairSync();
       }
   ```

   

3. **绑定多个条件**：ReentrantLock可以同时绑定多个Condition条件对象。

[java并发控制：ReentrantLock Condition使用详解-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/384548)

```java
package com.Test;

import org.junit.Test;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Description TODO
 * @Date 2021/10/28 22:43
 * @Created by 折腾的小飞
 */
public class ReentrantLockDemo {
    /**
     * description: 我们要打印1到9这9个数字，由A线程先打印1，2，3，然后由B线程打印4,5,6，
     * 然后再由A线程打印7，8，9. 这道题有很多种解法，
     * 现在我们使用Condition来做这道题（使用Object的wait，notify方法的解法在这里）。
     *
     * @since: 1.0.0
     * @author: 涂鏊飞tu_aofei@163.com
     * @date: 2021/10/28 22:49
     * @return: void
     */
    static class NumberWrapper {
        public int value = 1;
    }

    /*
    初始化可重入锁
     */
    final Lock lock = new ReentrantLock();

    @Test
    public void Demo() {
        //第一个条件当屏幕上输出到3
        final Condition reachThreeCondition = lock.newCondition();
        //第二个条件当屏幕上输出到6
        final Condition reachSixCondition = lock.newCondition();

        //NumberWrapper只是为了封装一个数字，一边可以将数字对象共享，并可以设置为final
        //注意这里不要用Integer, Integer 是不可变对象
        final NumberWrapper num = new NumberWrapper();

        //初始化A线程
        Thread threadA= new Thread(new Runnable() {
            public void run() {
                //需要先获得锁
                lock.lock();
                try {
                    System.out.println("threadA start write");
                    //A线程先输出前3个数
                    while (num.value <= 3) {
                        System.out.println(num.value);
                        num.value++;
                    }
                    //输出到3时要signal，告诉B线程可以开始了
                    reachThreeCondition.signal();
                }finally {
                    lock.unlock();
                }
                lock.lock();
                try{
                    //等待输出6的条件
                    reachSixCondition.await();
                    System.out.println("threadA start write");
                    //输出剩余数字
                    while (num.value <= 9) {
                        System.out.println(num.value);
                        num.value++;
                    }
                }catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {

                }
            }
        });

        Thread threadB = new Thread(new Runnable() {
            public void run() {
                try {
                    lock.lock();

                    while (num.value <= 3) {
                        //等待3输出完毕的信号
                        reachThreeCondition.await();
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock();
                }
                try {
                    lock.lock();
                    //已经收到信号，开始输出4，5，6
                    System.out.println("threadB start write");
                    while (num.value <= 6) {
                        System.out.println(num.value);
                        num.value++;
                    }
                    //4，5，6输出完毕，告诉A线程6输出完了
                    reachSixCondition.signal();
                } finally {
                    lock.unlock();
                }
            }

        });
        threadA.start();
        threadB.start();
    }
}
```

![image-20211030193235932](https://raw.githubusercontent.com/731016/imgSave/master/202110301932120.png)



## 好，说说HashMap原理吧？

HashMap主要由**数组和链表**组成，不是线程安全的。

插入数据用`put`，`get`查询数据以及扩容的方式。

jdk1.7和1.8的主要区别在于**头插**和**尾插**方式的修改,头插容易导致HashMap链表死循环，并且1.8后加入红黑树性能有提升。

### <u>put插入数据流程</u>

向map插入数据时获得**key的hash与数组长度-1进行与运算**【(n-1)&hash】。找到数组中的位置后，如果数组中**没有元素，则直接存入**，有元素则**判断key是否相同**，**相同则覆盖**，**不相同则插入到链表的尾部**，**如果链表长度超过8，则会转换成红黑树**，最后判断数组长度是否超过**默认长度*负载因子**（12），超过则进行扩容。

### <u>get查询数据</u>

首先计算hash值，去数组查询，是红黑树就去红黑树查，链表就遍历连表查询

### <u>resize扩容过程</u>

对key重写计算hash，把数据拷贝到新的数组



## 那多线程环境怎么使用Map呢？ConcurrentHashmap了解过吗？





