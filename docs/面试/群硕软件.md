## 面向对象是什么？举个生活中的例子

多喝热水

面对过程：把水倒入热水壶-》接电-》开始烧水-》完成烧水-》倒入水杯

面向对象：水，热水壶，杯子，电

## 面对过程和面向对象的区别？

**面向过程** ：**面向过程性能比面向对象高。** 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，**面向过程没有面向对象易维护、易复用、易扩展。**

**面向对象** ：**面向对象易维护、易复用、易扩展。** 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，**面向对象性能比面向过程低**。

## 面向对象的特征以及他们的作用

#### 封装

封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。

#### 继承

不同类型的对象，相互之间经常有一定数量的共同点。

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。



子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。

子类可以拥有自己属性和方法，即子类可以对父类进行扩展。

子类可以用自己的方式实现父类的方法。

#### 多态

表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例

**多态的特点:**

- 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；
- 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；
- 多态不能调用“只在子类存在但在父类不存在”的方法；
- 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。

## 简述TCP的三次握手

<img src="https://note-1259190304.cos.ap-chengdu.myqcloud.com/note/202111282033529.png" alt="image-20211127161115751" style="zoom:67%;" />

**三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的**



### 第 2 次握手传回了 ACK，为什么还要传回 SYN？

接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 SYN 则是为了建立并确认从服务端到客户端的通信。

## 四次挥手

<img src="https://note-1259190304.cos.ap-chengdu.myqcloud.com/note/202111282033499.png" alt="image-20211127162028159" style="zoom:67%;" />

- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号
- 服务器-关闭与客户端的连接，发送一个 FIN 给客户端
- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。



A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

## Session和cookie的区别

**Cookie 一般用来保存用户信息** 

① 我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；

② 一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；

③ 登录一次网站后访问网站其他页面不需要重新登录。

**Session 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

Cookie 数据保存在**客户端(浏览器端)**，Session 数据保存在**服务器端**。

Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密

## 为什么要创建单例

对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；

由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。



## 简述java垃圾回收机制

Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 **堆** 内存中对象的分配与回收。

Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用**分代垃圾收集算法**，所以 Java 堆还可以细分为：新生代和老年代

<img src="https://note-1259190304.cos.ap-chengdu.myqcloud.com/note/202111282033896.png" alt="image-20211127162808126" style="zoom:67%;" />

1. 创建和分配内存

2. 判断对象是否死亡 引用计数[**~~对象之间相互循环引用~~**]、可达性<img src="https://note-1259190304.cos.ap-chengdu.myqcloud.com/note/202111282032989.png" alt="image-20211127163737353" style="zoom: 50%;" />、4种引用[强、弱、软、虚]

   1. 当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题

   2. 如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。

   3. 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

   4. 虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。**虚引用主要用来跟踪对象被垃圾回收的活动**。

      > **虚引用与软引用和弱引用的一个区别在于：** 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

3. 回收算法

## jvm是什么？工作原理

JVM 又被称作 Java 虚拟机，用来运行 Java 字节码文件（`.class`）

Java文件经过编译后变成 .class 字节码文件

字节码文件通过类加载器被搬运到 JVM 虚拟机中

虚拟机主要的5大块：<u>**方法区**</u>，<u>**堆**</u>都为线程共享区域，有线程安全问题，<u>**栈**</u>和<u>**本地方法栈**</u>和<u>**计数器**</u>都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行

<img src="https://note-1259190304.cos.ap-chengdu.myqcloud.com/note/202111282033228.png" alt="image-20211127164747814" style="zoom: 67%;" />

**加载**

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个二进制字节流所代表的静态存储结构导入为方法区的运行时数据结构。
3. 在java堆中生成一个java.lang.Class对象，来代表的这个类，作为方法区这些数据的入口。

**链接**

1. 验证：保证二进制的字节流所包含的信息符号虚拟机的要求，并且不会危害到虚拟机自身的安全。
2. 准备：为 static 静态变量（类变量）分配内存，并为其设置初始值。
   - 注：这些内存都将在方法区内分配内存，实例变量在堆内存中，而且实例变量是在对象初始化时才赋值
3. 解析：解析阶段就是虚拟机将常量池中的符号引用转化为直接引用的过程。
   - 例如 import xxx.xxx.xxx 属于符号引用，而通过指针或者对象地址引用就是直接引用

**初始化**

1. 初始化会对变量进行赋值，即对最初的零值，进行显式初始化，例如`static int num = 0`变成了`static int num = 3`，这些工作都会在类构造器`<clinit>()`方法中执行。而且虚拟机保证了会先去执行父类`<clinit>()`方法 。
   - 如果在静态代码块中修改了静态变量的值，会对前面的显示初始化的值进行覆盖

**卸载**

GC 垃圾回收内存中的无用对象

<img src="C:\Users\折腾的小飞\AppData\Roaming\Typora\typora-user-images\image-20211128213301323.png" alt="image-20211128213301323" style="zoom:80%;" />

<img src="C:\Users\折腾的小飞\AppData\Roaming\Typora\typora-user-images\image-20211128213340028.png" alt="image-20211128213340028" style="zoom: 80%;" />

## api是干什么用的

相当于接口，我们只需要怎么使用参数和返回值，就能得到对应的结果

## servlet的工作原理

在Java Web程序中，**Servlet**主要负责接收用户请求 `HttpServletRequest`,在`doGet()`,`doPost()`中做相应的处理，并将回应`HttpServletResponse`反馈给用户。

**生命周期：** **Web容器加载Servlet并将其实例化后，Servlet生命周期开始**，容器运行其**init()方法**进行Servlet的初始化；请求到达时调用Servlet的**service()方法**，service()方法会根据需要调用与请求对应的**doGet或doPost**等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的**destroy()方法**。**init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行**。

[GET和POST两种基本请求方法的区别 - 在途中# - 博客园 (cnblogs.com)](https://www.cnblogs.com/logsharing/p/8448446.html)

## 数据库索引有哪些？使用它们的优点和缺点

索引的优点：
① 建立索引的列可以保证行的唯一性，生成唯一的rowId

② 建立索引可以有效缩短数据的检索时间

③ 建立索引可以加快表与表之间的连接

④ 为用来排序或者是分组的字段添加索引可以加快分组和排序顺序

索引的缺点：
① 创建索引和维护索引需要时间成本，这个成本随着数据量的增加而加大

② 创建索引和维护索引需要空间成本，每一条索引都要占据数据库的物理存储空间，数据量越大，占用空间也越大（数据表占据的是数据库的数据空间）

③ 会降低表的增删改的效率，因为每次增删改索引需要进行动态维护，导致时间变长

什么情况下需要建立索引
 数据量大的，经常进行查询操作的表要建立索引。

 用于排序的字段可以添加索引，用于分组的字段应当视情况看是否需要添加索引。

 表与表连接用于多表联合查询的约束条件的字段应当建立索引。

## try-catch和throws的区别，遇到异常try-catch和不try-catch的区别？finally语句是不是一定会执行？它里面会放什么样的语句？

try-catch 自己处理异常

throws 用再方法上，抛出异常给上层

如果遇到检查异常（属于exception），会让你处理使用throw throws try-catch处理；其他的会默认交给jvm处理

<img src="https://note-1259190304.cos.ap-chengdu.myqcloud.com/note/202111282034041.png" alt="image-20211127171400401" style="zoom:80%;" />

